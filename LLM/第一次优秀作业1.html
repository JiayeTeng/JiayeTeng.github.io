<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>大鱼吃小鱼</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: linear-gradient(#7ec8ff, #0477bf);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      user-select: none;
      -webkit-user-select: none;
    }
    #game-root {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }
    canvas {
      background: radial-gradient(1200px 800px at 50% 20%, rgba(255,255,255,0.12), rgba(255,255,255,0) 40%),
                  radial-gradient(800px 500px at 20% 70%, rgba(255,255,255,0.10), rgba(255,255,255,0) 50%),
                  radial-gradient(800px 500px at 80% 70%, rgba(255,255,255,0.10), rgba(255,255,255,0) 50%);
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25), inset 0 0 60px rgba(0,0,0,0.15);
    }
    .hud {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: 14px;
      display: flex;
      gap: 14px;
      padding: 8px 14px;
      color: #fff;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 999px;
      backdrop-filter: blur(8px);
      font-size: 14px;
      line-height: 1;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }
    .panel {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .card {
      pointer-events: auto;
      color: #083b66;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(8,59,102,0.15);
      border-radius: 16px;
      padding: 20px 22px;
      width: min(520px, 92vw);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      text-align: center;
    }
    .card h1 { margin: 0 0 8px 0; font-size: 22px; }
    .card p { margin: 6px 0; color: #0b4f88; }
    .btns { display: flex; gap: 10px; justify-content: center; margin-top: 12px; }
    button {
      appearance: none;
      border: none;
      padding: 10px 14px;
      font-size: 14px;
      border-radius: 10px;
      background: #0d8ef2;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(13,142,242,0.35);
    }
    button.secondary { background: transparent; color: #0d8ef2; border: 1px solid #0d8ef2; box-shadow: none; }
    .hidden { display: none; }
    @media (max-width: 900px) {
      .hud { top: auto; bottom: 12px; }
    }
  </style>
</head>
<body>
  <div class="hud" id="hud">
    <div>分数：<span id="score">0</span></div>
    <div>等级：<span id="level">1</span></div>
    <div>体型：<span id="size">10</span></div>
  </div>
  <div id="game-root">
    <canvas id="game" width="960" height="600"></canvas>
  </div>

  <div id="panel-start" class="panel">
    <div class="card">
      <h1>大鱼吃小鱼</h1>
      <p>使用键盘方向键或鼠标控制你的鱼。吃比你小的鱼来成长，躲开更大的鱼！</p>
      <div class="btns">
        <button id="btnStart">开始游戏</button>
        <button id="btnHow" class="secondary">玩法说明</button>
      </div>
    </div>
  </div>

  <div id="panel-how" class="panel hidden">
    <div class="card">
      <h1>玩法说明</h1>
      <p>键盘：↑ ↓ ← → 移动</p>
      <p>鼠标：移动至目标方向（不需要点击）</p>
      <p>吃掉比你体型小的鱼可得分并变大；碰到更大的鱼会失败。</p>
      <div class="btns">
        <button id="btnBack" class="secondary">返回</button>
      </div>
    </div>
  </div>

  <div id="panel-over" class="panel hidden">
    <div class="card">
      <h1>游戏结束</h1>
      <p>最终分数：<b id="finalScore">0</b></p>
      <p>最高分：<b id="bestScore">0</b></p>
      <div class="btns">
        <button id="btnRestart">再来一局</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudScore = document.getElementById('score');
    const hudLevel = document.getElementById('level');
    const hudSize = document.getElementById('size');

    const panelStart = document.getElementById('panel-start');
    const panelHow = document.getElementById('panel-how');
    const panelOver = document.getElementById('panel-over');
    const btnStart = document.getElementById('btnStart');
    const btnHow = document.getElementById('btnHow');
    const btnBack = document.getElementById('btnBack');
    const btnRestart = document.getElementById('btnRestart');
    const finalScore = document.getElementById('finalScore');
    const bestScore = document.getElementById('bestScore');

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const MAX_PLAYER_RADIUS = Math.min(WIDTH, HEIGHT) * 0.45; // 玩家体型上限
    const MAX_ENEMY_RADIUS = Math.min(WIDTH, HEIGHT) * 0.35;  // 敌鱼体型上限

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function randRange(min, max) { return Math.random() * (max - min) + min; }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function norm(v, a, b) { return (v - a) / (b - a); }
    function speedForRadius(r) {
      const t = clamp(norm(r, 10, MAX_PLAYER_RADIUS), 0, 1);
      // 体型越大速度越低，但保留较高的最低速度，保证手感
      return 3.2 - t * 0.9; // 3.2 -> 2.3
    }

    function circleIntersects(x1, y1, r1, x2, y2, r2) {
      const dx = x1 - x2; const dy = y1 - y2; const rr = r1 + r2;
      return dx * dx + dy * dy <= rr * rr;
    }

    function drawFish(x, y, size, color, directionX) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(directionX < 0 ? -1 : 1, 1);
      const bodyLen = size * 2.2;
      const bodyH = size * 1.2;

      // body
      const grd = ctx.createLinearGradient(-bodyLen * 0.6, 0, bodyLen * 0.6, 0);
      grd.addColorStop(0, '#ffffff');
      grd.addColorStop(0.25, color);
      grd.addColorStop(1, '#0b3b66');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyLen * 0.6, bodyH * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();

      // tail
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(-bodyLen * 0.8, 0);
      ctx.quadraticCurveTo(-bodyLen * 1.1, bodyH * 0.7, -bodyLen * 0.4, bodyH * 0.3);
      ctx.lineTo(-bodyLen * 0.4, -bodyH * 0.3);
      ctx.quadraticCurveTo(-bodyLen * 1.1, -bodyH * 0.7, -bodyLen * 0.8, 0);
      ctx.fill();

      // eye
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(bodyLen * 0.3, -bodyH * 0.15, size * 0.18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(bodyLen * 0.32, -bodyH * 0.15, size * 0.08, 0, Math.PI * 2);
      ctx.fill();

      // fins
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(0, bodyH * 0.35, size * 0.5, size * 0.25, 0.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawBubble(x, y, r) {
      ctx.save();
      const gradient = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, r * 0.1, x, y, r);
      gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.5)');
      gradient.addColorStop(1, 'rgba(255,255,255,0.05)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    window.addEventListener('keydown', e => {
      if (e.key in keys) keys[e.key] = true;
      if (e.key === ' ' || e.code === 'Space') {
        // 冲刺触发
        if (player && player.cdLeft === 0 && player.dashLeft === 0) {
          player.dashLeft = player.dashTime;
          player.cdLeft = player.dashCooldown;
          player.invulLeft = player.dashTime + player.invulAfterDash;
        }
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });

    let mouseX = WIDTH * 0.5, mouseY = HEIGHT * 0.5, mouseActive = false;
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
      mouseActive = true;
    });
    canvas.addEventListener('mouseleave', () => { mouseActive = false; });

    class Entity {
      constructor(x, y, radius) {
        this.x = x; this.y = y; this.radius = radius;
        this.vx = 0; this.vy = 0;
      }
    }

    class Player extends Entity {
      constructor() {
        super(WIDTH * 0.5, HEIGHT * 0.5, 10);
        this.speed = speedForRadius(10);
        this.color = '#35d0ff';
        this.score = 0;
        this.level = 1;
        this.facing = 1;
        this.baseRadius = 10;
        this.decayPerSecond = 0.02; // 体型每秒向基础体型衰减比例
        // dash 状态
        this.dashCooldown = 2.5; // 秒
        this.dashTime = 0.2;     // 秒
        this.dashSpeed = 7.0;    // 冲刺速度
        this.invulAfterDash = 0.2; // 冲刺后额外无敌
        this.cdLeft = 0;         // 冷却剩余
        this.dashLeft = 0;       // 冲刺剩余时间
        this.invulLeft = 0;      // 无敌剩余
      }
      update(dt) {
        let ax = 0, ay = 0;
        if (keys.ArrowUp) ay -= 1;
        if (keys.ArrowDown) ay += 1;
        if (keys.ArrowLeft) ax -= 1;
        if (keys.ArrowRight) ax += 1;
        if (mouseActive) {
          const dx = mouseX - this.x; const dy = mouseY - this.y;
          const len = Math.hypot(dx, dy) || 1;
          ax = dx / len; ay = dy / len;
        }
        // dash 计时
        if (this.cdLeft > 0) this.cdLeft = Math.max(0, this.cdLeft - dt);
        if (this.dashLeft > 0) {
          this.dashLeft = Math.max(0, this.dashLeft - dt);
          this.invulLeft = Math.max(this.invulLeft, this.dashLeft + this.invulAfterDash);
        }
        const currentSpeed = this.dashLeft > 0 ? this.dashSpeed : this.speed;
        this.vx = ax * currentSpeed;
        this.vy = ay * currentSpeed;
        // 当半径超过画布一半时，使用可用的最大夹取半径，避免边界区间反转导致卡住
        const clampR = Math.min(this.radius, WIDTH * 0.5 - 2, HEIGHT * 0.5 - 2);
        this.x = clamp(this.x + this.vx, clampR, WIDTH - clampR);
        this.y = clamp(this.y + this.vy, clampR, HEIGHT - clampR);
        if (this.vx !== 0) this.facing = Math.sign(this.vx);

        // 体型缓慢回落，避免无限变大
        const extra = Math.max(0, this.radius - this.baseRadius);
        if (extra > 0 && dt > 0) {
          const decay = extra * this.decayPerSecond * dt;
          this.radius = Math.max(this.baseRadius, this.radius - decay);
        }
        // 根据当前半径动态更新速度，避免大体型后手感过重
        this.speed = speedForRadius(this.radius);
        // 同步等级
        this.level = Math.max(1, 1 + Math.floor((this.radius - 10) / 6));
      }
      grow(by) {
        // 成长递减：越大时实际增长越少
        const growthDiminish = 1 / (1 + Math.max(0, (this.radius - 10)) / 18);
        const gain = by * growthDiminish;
        this.radius = Math.min(MAX_PLAYER_RADIUS, this.radius + gain);
        // 立刻重算速度，保证增长后的手感合理
        this.speed = speedForRadius(this.radius);
        this.level = Math.max(1, 1 + Math.floor((this.radius - 10) / 6));
      }
      draw() { drawFish(this.x, this.y, this.radius, this.color, this.facing); }
    }

    class Fish extends Entity {
      constructor(size, speed) {
        const side = Math.random() < 0.5 ? -1 : 1;
        const y = randRange(40, HEIGHT - 40);
        const x = side < 0 ? -60 : WIDTH + 60;
        super(x, y, size);
        this.vx = -side * randRange(speed * 0.8, speed * 1.2); // move inward
        this.vy = randRange(-0.3, 0.3);
        this.color = `hsl(${Math.floor(randRange(180, 220))}deg 80% ${Math.floor(randRange(45, 65))}%)`;
        this.facing = this.vx >= 0 ? 1 : -1;
        this.isEdible = true; // will be updated each frame
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        if (this.y < 30 || this.y > HEIGHT - 30) this.vy *= -1;
      }
      offscreen() { return this.x < -120 || this.x > WIDTH + 120; }
      draw() { drawFish(this.x, this.y, this.radius, this.color, this.facing); }
    }

    class Predator extends Entity {
      constructor(size) {
        const side = Math.random() < 0.5 ? -1 : 1;
        const y = randRange(60, HEIGHT - 60);
        const x = side < 0 ? -80 : WIDTH + 80;
        super(x, y, size);
        this.maxSpeed = 2.4; // 追踪速度
        this.color = '#ff6b6b';
        this.facing = side < 0 ? 1 : -1;
      }
      update() {
        // 简单追踪玩家
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const targetVx = (dx / d) * this.maxSpeed;
        const targetVy = (dy / d) * this.maxSpeed;
        // 平滑速度
        this.vx = lerp(this.vx, targetVx, 0.03);
        this.vy = lerp(this.vy, targetVy, 0.03);
        this.x += this.vx;
        this.y += this.vy;
        this.facing = this.vx >= 0 ? 1 : -1;
      }
      offscreen() { return this.x < -160 || this.x > WIDTH + 160 || this.y < -120 || this.y > HEIGHT + 120; }
      draw() { drawFish(this.x, this.y, this.radius, this.color, this.facing); }
    }

    class Bubble {
      constructor() {
        this.x = randRange(20, WIDTH - 20);
        this.y = HEIGHT + randRange(0, 200);
        this.r = randRange(3, 10);
        this.v = randRange(0.5, 1.5);
      }
      update() { this.y -= this.v; }
      offscreen() { return this.y < -20; }
      draw() { drawBubble(this.x, this.y, this.r); }
    }

    const player = new Player();
    let fishes = [];
    let bubbles = [];
    let spawnTimer = 0;
    let gameOver = false;
    let best = Number(localStorage.getItem('bigfish_best') || '0');

    function resetGame() {
      player.x = WIDTH * 0.5; player.y = HEIGHT * 0.5;
      player.radius = 10; player.score = 0; player.level = 1; player.speed = 2.6; player.facing = 1;
      fishes = []; bubbles = []; spawnTimer = 0; gameOver = false;
      for (let i = 0; i < 40; i++) bubbles.push(new Bubble());
      updateHud();
    }

    function updateHud() {
      hudScore.textContent = player.score.toString();
      hudLevel.textContent = player.level.toString();
      hudSize.textContent = Math.round(player.radius).toString();
    }

    function spawnFishWave() {
      // 混合：多数小鱼（可吃），少量同体型鱼，极少数更大鱼；偶尔生成捕食者
      const base = player.radius;
      const count = Math.floor(randRange(3, 6));
      for (let i = 0; i < count; i++) {
        const choice = Math.random();
        let s;
        if (choice < 0.55) {
          s = clamp(randRange(base * 0.4, base * 0.9), 6, MAX_ENEMY_RADIUS); // 小鱼
        } else if (choice < 0.9) {
          s = clamp(randRange(base * 0.9, base * 1.2), 6, MAX_ENEMY_RADIUS); // 接近体型
        } else {
          s = clamp(randRange(base * 1.2, base * 1.6), 12, MAX_ENEMY_RADIUS); // 稍大
        }
        const speed = clamp(2.0 - (s - 10) * 0.02, 0.6, 2.2);
        fishes.push(new Fish(s, speed));
      }
      // 捕食者：低概率生成，体型略大，但不超过上限
      if (Math.random() < 0.18) {
        const predSize = clamp(Math.max(base * 1.15, 16), 16, MAX_ENEMY_RADIUS);
        fishes.push(new Predator(predSize));
      }
    }

    function resolveCollisions() {
      for (let i = fishes.length - 1; i >= 0; i--) {
        const f = fishes[i];
        if (circleIntersects(player.x, player.y, player.radius * 0.85, f.x, f.y, f.radius * 0.85)) {
          if (f.radius < player.radius * 0.95) {
            // eat
            player.score += Math.max(1, Math.floor(6 - f.radius * 0.08));
            // 降低一次性成长幅度，并应用递减
            const rawGain = Math.max(0.3, f.radius * 0.12);
            player.grow(rawGain);
            fishes.splice(i, 1);
            updateHud();
          } else if (f.radius > player.radius * 1.05) {
            // 致命碰撞：若处于无敌则忽略并击退，否则结束
            if (player.invulLeft && player.invulLeft > 0) {
              const dx = player.x - f.x; const dy = player.y - f.y; const len = Math.hypot(dx, dy) || 1;
              player.x += (dx / len) * 10; player.y += (dy / len) * 10;
            } else {
              gameOver = true;
              best = Math.max(best, player.score);
              localStorage.setItem('bigfish_best', String(best));
              finalScore.textContent = String(player.score);
              bestScore.textContent = String(best);
              panelOver.classList.remove('hidden');
              break;
            }
          } else {
            // bump: small knock back
            const dx = player.x - f.x; const dy = player.y - f.y;
            const len = Math.hypot(dx, dy) || 1;
            player.x += (dx / len) * 6; player.y += (dy / len) * 6;
          }
        }
      }
    }

    function drawBackground() {
      // light caustics
      ctx.save();
      ctx.globalAlpha = 0.25;
      for (let i = 0; i < 3; i++) {
        const w = WIDTH * (1 - i * 0.1);
        const h = HEIGHT * (1 - i * 0.1);
        ctx.beginPath();
        ctx.ellipse(WIDTH * 0.5, HEIGHT * (0.1 + i * 0.1), w * 0.6, h * 0.2, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fill();
      }
      ctx.restore();
    }

    let lastTs = 0;
    function loop(ts) {
      const dt = lastTs ? (ts - lastTs) / 1000 : 0;
      lastTs = ts;
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawBackground();

      // bubbles
      if (Math.random() < 0.12) bubbles.push(new Bubble());
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i]; b.update(); b.draw();
        if (b.offscreen()) bubbles.splice(i, 1);
      }

      // player
      if (!gameOver) {
        player.update(dt);
        if (player.invulLeft > 0) player.invulLeft = Math.max(0, player.invulLeft - dt);
      }
      player.draw();

      // fishes
      spawnTimer -= 1;
      if (spawnTimer <= 0) { spawnFishWave(); spawnTimer = Math.floor(randRange(48, 90)); }
      for (let i = fishes.length - 1; i >= 0; i--) {
        const f = fishes[i];
        f.isEdible = f.radius < player.radius * 0.95;
        f.update();
        f.draw();
        if (f.offscreen()) fishes.splice(i, 1);
      }

      if (!gameOver) {
        resolveCollisions();
      }

      // 达到最大体型 -> 胜利
      if (!gameOver && player.radius >= MAX_PLAYER_RADIUS - 0.01) {
        gameOver = true;
        best = Math.max(best, player.score);
        localStorage.setItem('bigfish_best', String(best));
        finalScore.textContent = String(player.score);
        bestScore.textContent = String(best);
        panelOver.querySelector('h1').textContent = '胜利！';
        panelOver.classList.remove('hidden');
      } else if (gameOver) {
        // 复位“游戏结束”标题，避免下一局沿用“胜利！”
        panelOver.querySelector('h1').textContent = '游戏结束';
      }

      // guide text
      if (!gameStarted) {
        ctx.save();
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system';
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillText('按方向键或移动鼠标开始移动', 24, HEIGHT - 24);
        ctx.restore();
      }

      requestAnimationFrame(loop);
    }

    let gameStarted = false;
    function start() {
      panelStart.classList.add('hidden');
      panelHow.classList.add('hidden');
      panelOver.classList.add('hidden');
      resetGame();
      gameStarted = true;
    }

    btnStart.addEventListener('click', start);
    btnHow.addEventListener('click', () => { panelHow.classList.remove('hidden'); panelStart.classList.add('hidden'); });
    btnBack.addEventListener('click', () => { panelHow.classList.add('hidden'); panelStart.classList.remove('hidden'); });
    btnRestart.addEventListener('click', start);

    // kick off render loop
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>


